// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/chromeos/cert_provisioning/cert_provisioning_scheduler.h"

#include "base/bind.h"
#include "base/json/json_reader.h"
#include "base/test/gmock_callback_support.h"
#include "base/time/time.h"
#include "chrome/browser/chromeos/cert_provisioning/cert_provisioning_common.h"
#include "chrome/browser/chromeos/cert_provisioning/mock_cert_provisioning_worker.h"
#include "chrome/browser/chromeos/platform_keys/mock_platform_keys_service.h"
#include "chrome/browser/chromeos/platform_keys/platform_keys_service.h"
#include "chrome/browser/chromeos/platform_keys/platform_keys_service_factory.h"
#include "chrome/common/pref_names.h"
#include "chrome/test/base/testing_browser_process.h"
#include "chrome/test/base/testing_profile_manager.h"
#include "components/policy/core/common/cloud/mock_cloud_policy_client.h"
#include "components/prefs/testing_pref_service.h"
#include "content/public/test/browser_task_environment.h"
#include "testing/gtest/include/gtest/gtest.h"

using base::TimeDelta;
using base::test::RunOnceCallback;
using testing::_;
using testing::AtLeast;
using testing::Exactly;
using testing::Invoke;
using testing::Return;

namespace chromeos {
namespace cert_provisioning {
namespace {

// Generated by chrome/test/data/policy/test_certs/create_test_certs.sh
const char kFakeCertificate[] = R"(-----BEGIN CERTIFICATE-----
MIIDJzCCAg+gAwIBAgIBATANBgkqhkiG9w0BAQsFADAXMRUwEwYDVQQDDAxyb290
X2NhX2NlcnQwHhcNMjAwMjI1MTUyNTU2WhcNMzAwMjIyMTUyNTU2WjAUMRIwEAYD
VQQDDAkxMjcuMC4wLjEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDW
druvpaJovmyWzIcjtsSk/lp319+zNPSYGLzJzTeEmnFoDf/b89ft6xR1NIahmvVd
UHGOMlzgDKnNkqWw+pgpn6U8dk+leWnwlUefzDz7OY8qXfX29Vh0m/kATQc64lnp
rX19fEi2DOgH6heCQDSaHI/KAnAXccwl8kdGuTEnvdzbdHqQq8pPGpEqzC/NOjk7
kDNkUt0J74ZVMm4+jhVOgZ35mFLtC+xjfycBgbnt8yfPOzmOMwXTjYDPNaIy32AZ
t66oIToteoW5Ilg+j5Mto3unBDHrw8rml3+W/nwHuOPEIgBqLQFfWtXpuX8CbcS6
SFNK4hxCJOvlzUbgTpsrAgMBAAGjgYAwfjAMBgNVHRMBAf8EAjAAMB0GA1UdDgQW
BBRDEl1/2pL5LtKnpIly+XCj3N6MwDAfBgNVHSMEGDAWgBQrwVEnUQZlX850A2N+
URfS8BxoyzAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwDwYDVR0RBAgw
BocEfwAAATANBgkqhkiG9w0BAQsFAAOCAQEAXZd+Ul7GUFZPLSiTZ618hUI2UdO0
7rtPwBw3TephWuyEeHht+WhzA3sRL3nprEiJqIg5w/Tlfz4dsObpSU3vKmDhLzAx
HJrN5vKdbEj9wyuhYSRJwvJka1ZOgPzhQcDQOp1SqonNxLx/sSMDR2UIDMBGzrkQ
sDkn58N5eWm+hZADOAKROHR47j85VcsmYGK7z2x479YzsyWyOm0dbACXv7/HvFkz
56KvgxRaPZQzQUg5yuXa21IjQz07wyWSYnHpm2duAbYFl6CTR9Rlj5vpRkKsQP1W
mMhGDBfgEskdbM+0agsZrJupoQMBUbD5gflcJlW3kwlboi3dTtiGixfYWw==
-----END CERTIFICATE-----)";

struct CertificateTestHelper {
 public:
  CertificateTestHelper() {
    cert = CreateSingleCertificateFromBytes(kFakeCertificate,
                                            sizeof(kFakeCertificate));
    DCHECK(cert);
  }

  void GetCertificates(const std::string& token_id,
                       const platform_keys::GetCertificatesCallback& callback) {
    auto result = std::make_unique<net::CertificateList>();
    *result = cert_list;
    std::move(callback).Run(std::move(result), "");
  }

  void AddCert() {
    DCHECK(cert_list.empty())
        << "Current implementation supports only one certificate";
    cert_list.push_back(cert);
  }

  scoped_refptr<net::X509Certificate> GetCert() const { return cert; }

  std::string GetPublicKeyForCert() const {
    return platform_keys::GetSubjectPublicKeyInfo(cert);
  }

 private:
  scoped_refptr<net::X509Certificate> cert;
  net::CertificateList cert_list;
};

class CertProvisioningSchedulerTest : public testing::Test {
 public:
  CertProvisioningSchedulerTest() { Init(); }
  CertProvisioningSchedulerTest(const CertProvisioningSchedulerTest&) = delete;
  CertProvisioningSchedulerTest& operator=(
      const CertProvisioningSchedulerTest&) = delete;
  ~CertProvisioningSchedulerTest() override = default;

 protected:
  void Init() {
    RegisterProfilePrefs(pref_service_.registry());
    RegisterLocalStatePrefs(pref_service_.registry());

    testing_profile_manager_ = std::make_unique<TestingProfileManager>(
        TestingBrowserProcess::GetGlobal());
    ASSERT_TRUE(testing_profile_manager_->SetUp());
    testing_profile_ =
        testing_profile_manager_->CreateTestingProfile("user@gmail.com");
    ASSERT_TRUE(testing_profile_);

    platform_keys_service_ =
        static_cast<platform_keys::MockPlatformKeysService*>(
            platform_keys::PlatformKeysServiceFactory::GetInstance()
                ->SetTestingFactoryAndUse(
                    testing_profile_,
                    base::BindRepeating(
                        &platform_keys::BuildMockPlatformKeysService)));
    ASSERT_TRUE(platform_keys_service_);
  }

  void FastForwardBy(base::TimeDelta delta) {
    task_environment_.FastForwardBy(delta);
  }

  void SetUp() override {
    CertProvisioningWorkerFactory::SetFactoryForTesting(&testing_factory_);

    EXPECT_CALL(*platform_keys_service_, GetCertificates)
        .WillRepeatedly(Invoke(&certificate_helper_,
                               &CertificateTestHelper::GetCertificates));
  }

  void TearDown() override {
    // Check that we don't have unused workers in the factory.
    EXPECT_EQ(testing_factory_.ResultsCount(), 0U);
    testing_factory_.Reset();

    CertProvisioningWorkerFactory::SetFactoryForTesting(nullptr);
  }

  MockCertProvisioningWorker* CreateMockWorker(const std::string& profile_id) {
    auto worker_obj = std::make_unique<MockCertProvisioningWorker>();
    MockCertProvisioningWorker* worker = worker_obj.get();
    testing_factory_.Push(std::move(worker_obj));
    return worker;
  }

  content::BrowserTaskEnvironment task_environment_{
      base::test::TaskEnvironment::TimeSource::MOCK_TIME};

  std::unique_ptr<TestingProfileManager> testing_profile_manager_;
  TestingProfile* testing_profile_ = nullptr;

  platform_keys::MockPlatformKeysService* platform_keys_service_ = nullptr;

  TestingPrefServiceSimple pref_service_;
  policy::MockCloudPolicyClient cloud_policy_client_;
  CertProvisioningWorkerFactoryForTesting testing_factory_;
  CertificateTestHelper certificate_helper_;
};

TEST_F(CertProvisioningSchedulerTest, Success) {
  CertScope cert_scope = CertScope::kUser;
  const char kCertProfileId[] = "cert_profile_id_1";

  MockCertProvisioningWorker* worker = CreateMockWorker(kCertProfileId);
  worker->SetExpectations(/*do_step_times=*/AtLeast(1), /*is_waiting=*/false);
  ASSERT_EQ(testing_factory_.ResultsCount(), 1U);

  CertProvisioningScheduler scheduler(
      cert_scope, testing_profile_, &pref_service_,
      prefs::kRequiredClientCertificateForUser, &cloud_policy_client_);

  // The policy is empty, so no workers should be created yet.
  FastForwardBy(base::TimeDelta::FromSeconds(1));
  EXPECT_EQ(scheduler.GetWorkerCount(), 0U);
  ASSERT_EQ(testing_factory_.ResultsCount(), 1U);

  // Add 1 certificate profile to the policy.
  base::Optional<base::Value> config = base::JSONReader::Read(
      R"([{"name": "Certificate Profile 1",
           "cert_profile_id":"cert_profile_id_1",
           "key_algorithm":"rsa",
           "renewal_period_seconds": 365000}])");
  ASSERT_TRUE(config.has_value());
  pref_service_.Set(prefs::kRequiredClientCertificateForUser, config.value());

  // Now 1 worker should be created.
  FastForwardBy(base::TimeDelta::FromSeconds(1));
  EXPECT_EQ(scheduler.GetWorkerCount(), 1U);
  ASSERT_EQ(testing_factory_.ResultsCount(), 0U);

  // Emulate callback from the worker.
  scheduler.OnProfileFinished(kCertProfileId, true);

  // Finished worker should be deleted.
  EXPECT_EQ(scheduler.GetWorkerCount(), 0U);
  EXPECT_EQ(scheduler.GetFailedCertProfilesIds(), std::set<std::string>{});

  certificate_helper_.AddCert();

  EXPECT_CALL(
      *platform_keys_service_,
      GetAttributeForKey(
          GetPlatformKeysTokenId(cert_scope),
          certificate_helper_.GetPublicKeyForCert(),
          platform_keys::KeyAttributeType::CertificateProvisioningId, _))
      .Times(1)
      .WillOnce(base::test::RunOnceCallback<3>(kCertProfileId, ""));

  // Check one more time that scheduler doesn't create new workers for
  // finished certificate profiles (the factory will fail on an attempt to
  // do so).
  scheduler.UpdateCerts();

  FastForwardBy(base::TimeDelta::FromSeconds(100));
}

TEST_F(CertProvisioningSchedulerTest, WorkerFailed) {
  CertScope cert_scope = CertScope::kDevice;
  const char kCertProfileId[] = "cert_profile_id_1";

  MockCertProvisioningWorker* worker = CreateMockWorker(kCertProfileId);
  worker->SetExpectations(/*do_step_times=*/AtLeast(1), /*is_waiting=*/false);
  ASSERT_EQ(testing_factory_.ResultsCount(), 1U);

  CertProvisioningScheduler scheduler(
      cert_scope, testing_profile_, &pref_service_,
      prefs::kRequiredClientCertificateForDevice, &cloud_policy_client_);

  // The policy is empty, so no workers should be created yet.
  FastForwardBy(base::TimeDelta::FromSeconds(1));
  EXPECT_EQ(scheduler.GetWorkerCount(), 0U);
  ASSERT_EQ(testing_factory_.ResultsCount(), 1U);

  // Add 1 certificate profile to the policy.
  base::Optional<base::Value> config = base::JSONReader::Read(
      R"([{"name": "Certificate Profile 1",
           "cert_profile_id":"cert_profile_id_1",
           "key_algorithm":"rsa",
           "renewal_period_seconds": 365000}])");
  ASSERT_TRUE(config.has_value());
  pref_service_.Set(prefs::kRequiredClientCertificateForDevice, config.value());

  // Now 1 worker should be created.
  FastForwardBy(base::TimeDelta::FromSeconds(1));
  EXPECT_EQ(scheduler.GetWorkerCount(), 1U);
  ASSERT_EQ(testing_factory_.ResultsCount(), 0U);

  // Emulate callback from the worker.
  scheduler.OnProfileFinished(kCertProfileId, false);

  // Failed worker should be deleted, failed profile ID is saved, no new workers
  // should be created.
  EXPECT_EQ(scheduler.GetWorkerCount(), 0U);
  EXPECT_EQ(scheduler.GetFailedCertProfilesIds(),
            std::set<std::string>{kCertProfileId});

  certificate_helper_.AddCert();

  EXPECT_CALL(
      *platform_keys_service_,
      GetAttributeForKey(
          GetPlatformKeysTokenId(cert_scope),
          certificate_helper_.GetPublicKeyForCert(),
          platform_keys::KeyAttributeType::CertificateProvisioningId, _))
      .Times(1)
      .WillOnce(base::test::RunOnceCallback<3>(kCertProfileId, ""));

  // Check one more time that scheduler doesn't create new workers for failed
  // certificate profiles (the factory will fail on an attempt to do so).
  scheduler.UpdateCerts();
}

TEST_F(CertProvisioningSchedulerTest, InitialAndDailyUpdates) {
  // Add 1 certificate profile to the policy.
  base::Optional<base::Value> config = base::JSONReader::Read(
      R"([{"name": "Certificate Profile 1",
           "cert_profile_id":"cert_profile_id_1",
           "key_algorithm":"rsa",
           "renewal_period_seconds": 365000}])");
  ASSERT_TRUE(config.has_value());
  pref_service_.Set(prefs::kRequiredClientCertificateForUser, config.value());

  const char kCertProfileId[] = "cert_profile_id_1";
  MockCertProvisioningWorker* worker = CreateMockWorker(kCertProfileId);
  worker->SetExpectations(/*do_step_times=*/AtLeast(1), /*is_waiting=*/false);
  ASSERT_EQ(testing_factory_.ResultsCount(), 1U);

  CertProvisioningScheduler scheduler(
      CertScope::kDevice, testing_profile_, &pref_service_,
      prefs::kRequiredClientCertificateForUser, &cloud_policy_client_);

  // Now one worker should be created.
  FastForwardBy(base::TimeDelta::FromSeconds(1));
  ASSERT_EQ(scheduler.GetWorkerCount(), 1U);
  ASSERT_EQ(testing_factory_.ResultsCount(), 0U);

  // Emulate callback from the worker.
  scheduler.OnProfileFinished(kCertProfileId, false);

  ASSERT_EQ(scheduler.GetWorkerCount(), 0U);
  EXPECT_EQ(scheduler.GetFailedCertProfilesIds(),
            std::set<std::string>{kCertProfileId});

  FastForwardBy(base::TimeDelta::FromHours(12));
  ASSERT_EQ(scheduler.GetWorkerCount(), 0U);

  MockCertProvisioningWorker* worker2 = CreateMockWorker(kCertProfileId);
  worker2->SetExpectations(/*do_step_times=*/AtLeast(1), /*is_waiting=*/false);
  ASSERT_EQ(testing_factory_.ResultsCount(), 1U);

  FastForwardBy(base::TimeDelta::FromHours(13));
  ASSERT_EQ(scheduler.GetWorkerCount(), 1U);
  ASSERT_EQ(testing_factory_.ResultsCount(), 0U);

  // Emulate callback from the worker.
  scheduler.OnProfileFinished(kCertProfileId, true);

  ASSERT_EQ(scheduler.GetWorkerCount(), 0U);
  EXPECT_EQ(scheduler.GetFailedCertProfilesIds(), std::set<std::string>{});
}

TEST_F(CertProvisioningSchedulerTest, MultipleWorkers) {
  CertScope cert_scope = CertScope::kDevice;
  const char kCertProfileId0[] = "cert_profile_id_0";
  const char kCertProfileId1[] = "cert_profile_id_1";
  const char kCertProfileId2[] = "cert_profile_id_2";

  MockCertProvisioningWorker* worker0 = CreateMockWorker(kCertProfileId0);
  worker0->SetExpectations(/*do_step_times=*/AtLeast(1), /*is_waiting=*/false);
  MockCertProvisioningWorker* worker1 = CreateMockWorker(kCertProfileId1);
  worker1->SetExpectations(/*do_step_times=*/AtLeast(1), /*is_waiting=*/false);
  MockCertProvisioningWorker* worker2 = CreateMockWorker(kCertProfileId2);
  worker2->SetExpectations(/*do_step_times=*/AtLeast(1), /*is_waiting=*/false);
  ASSERT_EQ(testing_factory_.ResultsCount(), 3U);

  CertProvisioningScheduler scheduler(
      cert_scope, testing_profile_, &pref_service_,
      prefs::kRequiredClientCertificateForDevice, &cloud_policy_client_);

  // The policy is empty, so no workers should be created yet.
  FastForwardBy(base::TimeDelta::FromSeconds(1));
  ASSERT_EQ(scheduler.GetWorkerCount(), 0U);
  ASSERT_EQ(testing_factory_.ResultsCount(), 3U);

  // Add 3 certificate profiles to the policy.
  base::Optional<base::Value> config = base::JSONReader::Read(
      R"([{
           "name": "Certificate Profile 1",
           "cert_profile_id":"cert_profile_id_0",
           "key_algorithm":"rsa",
           "renewal_period_seconds": 365000
          },
          {
           "name": "Certificate Profile 2",
           "cert_profile_id":"cert_profile_id_1",
           "key_algorithm":"rsa",
           "renewal_period_seconds": 365000
          },
          {
           "name": "Certificate Profile 3",
           "cert_profile_id":"cert_profile_id_2",
           "key_algorithm":"rsa",
           "renewal_period_seconds": 365000
          }])");
  ASSERT_TRUE(config.has_value());
  pref_service_.Set(prefs::kRequiredClientCertificateForDevice, config.value());

  // Now one worker for each profile should be created.
  FastForwardBy(base::TimeDelta::FromSeconds(1));
  ASSERT_EQ(scheduler.GetWorkerCount(), 3U);
  ASSERT_EQ(testing_factory_.ResultsCount(), 0U);

  // worker0 successfully finished. Should be just deleted.
  scheduler.OnProfileFinished(kCertProfileId0, true);

  // worker1 is waiting. Should be continued.
  worker1->SetExpectations(/*do_step_times=*/AtLeast(1), /*is_waiting=*/true);

  // worker2 failed. Should be deleted and the profile id should be saved.
  scheduler.OnProfileFinished(kCertProfileId2, false);

  EXPECT_EQ(scheduler.GetWorkerCount(), 1U);
  EXPECT_EQ(scheduler.GetFailedCertProfilesIds(),
            std::set<std::string>{kCertProfileId2});

  certificate_helper_.AddCert();

  EXPECT_CALL(
      *platform_keys_service_,
      GetAttributeForKey(
          GetPlatformKeysTokenId(cert_scope),
          certificate_helper_.GetPublicKeyForCert(),
          platform_keys::KeyAttributeType::CertificateProvisioningId, _))
      .Times(1)
      .WillOnce(base::test::RunOnceCallback<3>(kCertProfileId0, ""));

  // Make scheduler check workers state.
  scheduler.UpdateCerts();

  EXPECT_EQ(scheduler.GetWorkerCount(), 1U);
  EXPECT_EQ(scheduler.GetFailedCertProfilesIds(),
            std::set<std::string>{kCertProfileId2});

  EXPECT_CALL(
      *platform_keys_service_,
      GetAttributeForKey(
          GetPlatformKeysTokenId(cert_scope),
          certificate_helper_.GetPublicKeyForCert(),
          platform_keys::KeyAttributeType::CertificateProvisioningId, _))
      .Times(1)
      .WillOnce(base::test::RunOnceCallback<3>(kCertProfileId0, ""));

  // Check one more time that scheduler doesn't create new workers for failed
  // certificate profiles (the factory will fail on an attempt to do so).
  scheduler.UpdateCerts();
  EXPECT_EQ(scheduler.GetWorkerCount(), 1U);
}

TEST_F(CertProvisioningSchedulerTest, RemoveCertWithoutPolicy) {
  CertScope cert_scope = CertScope::kDevice;
  const char kCertProfileId[] = "cert_profile_id_1";

  certificate_helper_.AddCert();

  EXPECT_CALL(*platform_keys_service_,
              GetAttributeForKey(
                  GetPlatformKeysTokenId(cert_scope),
                  certificate_helper_.GetPublicKeyForCert(),
                  platform_keys::KeyAttributeType::CertificateProvisioningId,
                  /*callback=*/_))
      .Times(1)
      .WillOnce(base::test::RunOnceCallback<3>(kCertProfileId, ""));

  CertProvisioningScheduler scheduler(
      cert_scope, testing_profile_, &pref_service_,
      prefs::kRequiredClientCertificateForDevice, &cloud_policy_client_);

  EXPECT_CALL(*platform_keys_service_,
              RemoveCertificate(GetPlatformKeysTokenId(cert_scope),
                                /*certificate=*/certificate_helper_.GetCert(),
                                /*callback=*/_))
      .Times(1);

  FastForwardBy(base::TimeDelta::FromSeconds(1));
}

}  // namespace
}  // namespace cert_provisioning
}  // namespace chromeos
