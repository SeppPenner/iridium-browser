<script src="resources/testharness.js"></script>
<script src="/script/async_buffer.js"></script>
<script>
// Tell testharness.js to not wait for 'real' tests; we only want
// testharness.js for its assertion helpers.
setup({'output': false});
</script>

<script>
  const buffer = new AsyncBuffer();
  const po = new PerformanceObserver(entryList => {
    buffer.push(entryList.getEntries());
  });
  po.observe({type: 'largest-contentful-paint', buffered: true});
</script>

<div id="content_div_1">
  <img src="images/green-16x16.png"></img>
</div>
<div id="content_div_2">
</div>

<script>
  const block_for_next_lcp = async () => {
    return buffer.pop().then(seen_events => {
      // This test case assumes each LCP entry is handled before the next could
      // possibly be generated.
      assert_equals(seen_events.length, 1);
      return seen_events[0];
    });
  };

  // Adds another image that is larger than "green-16x16.png". We expect this
  // operation to trigger a new LCP entry.
  const add_larger_image = () => {
    let new_img = document.createElement("img");
    content_div_2.appendChild(new_img);
    new_img.src = "images/blue96x96.png";
    new_img.id = "blue_image";
  };

  // Removes the image added by 'add_larger_image'. We expect this operation to
  // trigger a new LCP entry.
  const remove_larger_image = () => {
    const blue_image = document.getElementById("blue_image");
    assert_not_equals(blue_image, null);
    content_div_2.removeChild(blue_image);
  };

  const run_test = async () => {
    // This test exerciess the following scenario
    //  - have an initial page load with an image
    //  - assert that LCP fires for that image
    //  - add a larger image to the page
    //  - assert that LCP fires for the new image
    //  - remove the larger image
    //  - assert that LCP fires (again) for the first image
    const lcp_0 = await block_for_next_lcp();
    add_larger_image();
    const lcp_1 = await block_for_next_lcp();
    remove_larger_image();
    const lcp_2 = await block_for_next_lcp();

    // Now that we've run through the scenario and collected our measurements,
    // return them in a structure that the C++ side can easily query.
    let output = [
    // lcp_0
    {
      url: lcp_0.url,
      time: lcp_0.startTime
    },
    // lcp_1
    {
      url: lcp_1.url,
      time: lcp_1.startTime
    },
    // lcp_2
    {
      url: lcp_2.url,
      time: lcp_2.startTime
    }
    ];
    return output;
  };
</script>
