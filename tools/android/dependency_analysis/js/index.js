// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * TODO(yjlong): Compute the "shortest disambiguated name" in Python and include
 * it in the JSON so we do not need to do this calculation.
 * @param {number} name The full package name to shorten.
 * @return {number} The shortened package name.
 */
const shortName = (name) => name.substring(name.lastIndexOf('.') + 1);

/*
 * Transforms a graph JSON generated by Python scripts
 * (generate_json_dependency_graph.py) into a working format for d3.
 * TODO(yjlong): Figure out if we want to typecheck the graph.
 */
function parseNodesAndEdgesFromJson(graph) {
  const nodes = graph.nodes.map((node) => ({
    ...node,
    id: node.name,
    short_name: shortName(node.name),
  }));
  const edges = graph.edges.map((edge) => ({
    ...edge,
    id: `${edge.begin}>${edge.end}`,
    // The names source/target are needed for d3-force links.
    source: edge.begin,
    target: edge.end,
  }));
  return [nodes, edges];
}

function renderJsonGraph(data) {
  const [jsonNodes, jsonEdges] = parseNodesAndEdgesFromJson(data.package_graph);

  const svg = d3.select('svg');

  // TODO(yjlong): SVG should be resizable & these values updated.
  const width = +svg.attr('width');
  const height = +svg.attr('height');

  const simulation = d3.forceSimulation()
      .nodes(jsonNodes)
      .alphaMin(0.1) // Stop the simulation faster than default (0.001).
      .force('chargeForce', d3.forceManyBody().strength(-300))
      .force('centerForce', d3.forceCenter(width / 2, height / 2))
      .force('links', d3.forceLink(jsonEdges).id((d) => d.id));

  const edgeGroup = svg.append('g')
      .classed('graph-edges', true)
      .attr('stroke-width', 1);
  const edges = edgeGroup.selectAll('line')
      .data(jsonEdges)
      .join((enter) => enter.append('line'));

  const dragStarted = (d, i, nodes) => {
    d3.event.sourceEvent.stopPropagation();
    d3.select(nodes[i]).classed('dragging', false);
    d.fx = null;
    d.fy = null;
  };

  const dragged = (d, i, nodes) => {
    simulation.alpha(0.3).restart(); // Reheat the simulation on drag.
    d3.select(nodes[i]).classed('dragging', true);
    // Fix the node's position after it has been dragged.
    d.fx = d3.event.x;
    d.fy = d3.event.y;
  };

  const nodeGroup = svg.append('g')
      .classed('graph-nodes', true)
      .attr('fill', 'red');
  const nodes = nodeGroup.selectAll('circle')
      .data(jsonNodes)
      .join((enter) => enter.append('circle'))
      .attr('r', 5)
      .call(d3.drag()
          .on('start', dragStarted)
          .on('drag', dragged));

  const labelGroup = svg.append('g')
      .classed('graph-labels', true);
  const labels = labelGroup.selectAll('text')
      .data(jsonNodes)
      .join((enter) => enter.append('text'))
      .attr('dx', 12)
      .attr('dy', '.35em')
      .text((d) => d.short_name);

  // The simulation updates position variables in the JSON, it's up to us
  // to update the visualization to match on each tick.
  const tickActions = () => {
    nodes
        .attr('cx', (d) => d.x)
        .attr('cy', (d) => d.y);

    edges
        .attr('x1', (d) => d.source.x)
        .attr('y1', (d) => d.source.y)
        .attr('x2', (d) => d.target.x)
        .attr('y2', (d) => d.target.y);

    labels
        .attr('x', (d) => d.x)
        .attr('y', (d) => d.y);
  };

  simulation.on('tick', tickActions);
}

// TODO(yjlong): Currently we take JSON served by a Python server running on
// the side. Replace this with a user upload or pull from some other source.
document.addEventListener('DOMContentLoaded', () => {
  d3.json('http://localhost:8888/json_graph.txt')
      .then((data) => renderJsonGraph(data));
});
