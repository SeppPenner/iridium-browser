From 89684b11198785e6bc0cd3bb22f762c97a54c05c Mon Sep 17 00:00:00 2001
From: Jan Engelhardt <jengelh@inai.de>
Date: Wed, 20 May 2015 01:34:50 +0200
Subject: [PATCH 47/50] iridium: help identify possibly evil hardcoded URLs

The Chromium codebase has left us with a number of suspect URLs, and
we want to know if the browser attempts to contact those sites.

This patch introduces a new scheme, "trk:", which, when attempted to
being processed, will dump a warning onto the screen as the resource
is loaded. All URLs we think are suspect are "blacklisted" by
prepending the new scheme to an existing URL:

	trk:1234:https://clients4.google.com/ (or)
	trk:https://clients4.google.com/

At seeing a warning, we then know that investigation needs to be done,
either to (a) whitelist the URL, that is, remove the trk: prefix and
not show the warning, and/or (b) disable the particular feature which
caused the loading of the URL in the first place, by default.

Implementation:

We hack up the URLFetcher class which sits in the network stack, and
most of the URL that get loaded pass through here. The trk: prefix is
stripped and processing continues with the inner URL. There is also a
browser-level scheme handler for trk:, not sure if we still need it
(relict from 43.0~test2). It might trigger.
---
 .../chrome_autocomplete_scheme_classifier.cc       |  1 +
 chrome/browser/history/history_utils.cc            |  1 +
 chrome/browser/ui/browser_command_controller.cc    |  3 ++-
 chrome/browser/ui/browser_navigator.cc             |  8 ++++++
 chrome/browser/ui/singleton_tabs.cc                |  3 ++-
 components/omnibox/autocomplete_input.cc           |  8 +++---
 content/browser/browser_url_handler_impl.cc        | 31 ++++++++++++++++++++++
 .../browser/child_process_security_policy_impl.cc  |  7 +++--
 net/url_request/url_request.cc                     | 18 +++++++++++++
 url/gurl.cc                                        | 21 +++++++++++++++
 url/gurl.h                                         |  3 +++
 url/url_constants.cc                               |  1 +
 url/url_constants.h                                |  1 +
 13 files changed, 99 insertions(+), 7 deletions(-)

diff --git a/chrome/browser/autocomplete/chrome_autocomplete_scheme_classifier.cc b/chrome/browser/autocomplete/chrome_autocomplete_scheme_classifier.cc
index c64520f..47b3b12 100644
--- a/chrome/browser/autocomplete/chrome_autocomplete_scheme_classifier.cc
+++ b/chrome/browser/autocomplete/chrome_autocomplete_scheme_classifier.cc
@@ -26,6 +26,7 @@ ChromeAutocompleteSchemeClassifier::GetInputTypeForScheme(
   if (base::IsStringASCII(scheme) &&
       (ProfileIOData::IsHandledProtocol(scheme) ||
        LowerCaseEqualsASCII(scheme, content::kViewSourceScheme) ||
+       LowerCaseEqualsASCII(scheme, url::kTraceScheme) ||
        LowerCaseEqualsASCII(scheme, url::kJavaScriptScheme) ||
        LowerCaseEqualsASCII(scheme, url::kDataScheme))) {
     return metrics::OmniboxInputType::URL;
diff --git a/chrome/browser/history/history_utils.cc b/chrome/browser/history/history_utils.cc
index 1bc5e8d..6e7210a 100644
--- a/chrome/browser/history/history_utils.cc
+++ b/chrome/browser/history/history_utils.cc
@@ -19,6 +19,7 @@ bool CanAddURLToHistory(const GURL& url) {
       url.SchemeIs(content::kChromeDevToolsScheme) ||
       url.SchemeIs(content::kChromeUIScheme) ||
       url.SchemeIs(content::kViewSourceScheme) ||
+      url.SchemeIs(url::kTraceScheme) ||
       url.SchemeIs(chrome::kChromeNativeScheme) ||
       url.SchemeIs(chrome::kChromeSearchScheme) ||
       url.SchemeIs(dom_distiller::kDomDistillerScheme))
diff --git a/chrome/browser/ui/browser_command_controller.cc b/chrome/browser/ui/browser_command_controller.cc
index a7b5229..10ee382 100644
--- a/chrome/browser/ui/browser_command_controller.cc
+++ b/chrome/browser/ui/browser_command_controller.cc
@@ -103,7 +103,8 @@ bool HasInternalURL(const NavigationEntry* entry) {
 
   // If the |virtual_url()| isn't a chrome:// URL, check if it's actually
   // view-source: of a chrome:// URL.
-  if (entry->GetVirtualURL().SchemeIs(content::kViewSourceScheme))
+  if (entry->GetVirtualURL().SchemeIs(content::kViewSourceScheme) ||
+      entry->GetVirtualURL().SchemeIs(url::kTraceScheme))
     return entry->GetURL().SchemeIs(content::kChromeUIScheme);
 
   return false;
diff --git a/chrome/browser/ui/browser_navigator.cc b/chrome/browser/ui/browser_navigator.cc
index 4a51584..2820adf 100644
--- a/chrome/browser/ui/browser_navigator.cc
+++ b/chrome/browser/ui/browser_navigator.cc
@@ -732,6 +732,14 @@ bool IsURLAllowedInIncognito(const GURL& url,
     return stripped_url.is_valid() &&
         IsURLAllowedInIncognito(stripped_url, browser_context);
   }
+
+	if (url.SchemeIs(url::kTraceScheme)) {
+		/* Same as view-source:, strip prefix and re-check. */
+		auto url2 = url.strip_trk();
+		return url2.is_valid() &&
+		       IsURLAllowedInIncognito(url2, browser_context);
+	}
+
   // Most URLs are allowed in incognito; the following are exceptions.
   // chrome://extensions is on the list because it redirects to
   // chrome://settings.
diff --git a/chrome/browser/ui/singleton_tabs.cc b/chrome/browser/ui/singleton_tabs.cc
index 60cf852..cd58a4b 100644
--- a/chrome/browser/ui/singleton_tabs.cc
+++ b/chrome/browser/ui/singleton_tabs.cc
@@ -98,7 +98,8 @@ int GetIndexOfSingletonTab(NavigateParams* params) {
 
     // Skip view-source tabs. This is needed because RewriteURLIfNecessary
     // removes the "view-source:" scheme which leads to incorrect matching.
-    if (tab_url.SchemeIs(content::kViewSourceScheme))
+    if (tab_url.SchemeIs(content::kViewSourceScheme) ||
+        tab_url.SchemeIs(url::kTraceScheme))
       continue;
 
     GURL rewritten_tab_url = tab_url;
diff --git a/components/omnibox/autocomplete_input.cc b/components/omnibox/autocomplete_input.cc
index 2c6982b..997d26f 100644
--- a/components/omnibox/autocomplete_input.cc
+++ b/components/omnibox/autocomplete_input.cc
@@ -421,7 +421,8 @@ void AutocompleteInput::ParseForEmphasizeComponents(
   int after_scheme_and_colon = parts.scheme.end() + 1;
   // For the view-source scheme, we should emphasize the scheme and host of the
   // URL qualified by the view-source prefix.
-  if (LowerCaseEqualsASCII(scheme_str, kViewSourceScheme) &&
+  if ((LowerCaseEqualsASCII(scheme_str, kViewSourceScheme) ||
+       LowerCaseEqualsASCII(scheme_str, url::kTraceScheme)) &&
       (static_cast<int>(text.length()) > after_scheme_and_colon)) {
     // Obtain the URL prefixed by view-source and parse it.
     base::string16 real_url(text.substr(after_scheme_and_colon));
@@ -488,9 +489,10 @@ int AutocompleteInput::NumNonHostComponents(const url::Parsed& parts) {
 bool AutocompleteInput::HasHTTPScheme(const base::string16& input) {
   std::string utf8_input(base::UTF16ToUTF8(input));
   url::Component scheme;
-  if (url::FindAndCompareScheme(utf8_input, kViewSourceScheme, &scheme)) {
+  if (url::FindAndCompareScheme(utf8_input, url::kTraceScheme, &scheme))
+    gurl_strip_trk(utf8_input);
+  else if (url::FindAndCompareScheme(utf8_input, kViewSourceScheme, &scheme))
     utf8_input.erase(0, scheme.end() + 1);
-  }
   return url::FindAndCompareScheme(utf8_input, url::kHttpScheme, NULL);
 }
 
diff --git a/content/browser/browser_url_handler_impl.cc b/content/browser/browser_url_handler_impl.cc
index 438feb3..3b143ed 100644
--- a/content/browser/browser_url_handler_impl.cc
+++ b/content/browser/browser_url_handler_impl.cc
@@ -13,6 +13,36 @@
 
 namespace content {
 
+static bool handle_trace_scheme(GURL *url, BrowserContext *)
+{
+	if (!url->SchemeIs(url::kTraceScheme))
+		return false;
+#ifdef __linux__
+	bool tty = isatty(fileno(stderr));
+#else
+	bool tty = false;
+#endif
+	/*
+	 * This function normally should not be called anymore
+	 * (unless you manually enter a trk: URL). Leave it in, maybe it does
+	 * happen again.
+	 */
+	const char *xhi    = tty ? "\033[1;32;45m" : ""; // ]
+	const char *xreset = tty ? "\033[0m" : ""; // ]
+	fprintf(stderr, "%s*** handle_trace_scheme(%s)%s\n",
+	        xhi, url->possibly_invalid_spec().c_str(), xreset);
+	*url = url->strip_trk();
+	return false;
+}
+
+static bool trace_scheme_revlookup(GURL *url, BrowserContext *)
+{
+	if (url->SchemeIs(url::kTraceScheme))
+		return false;
+	*url = GURL(url::kTraceScheme + (":" + url->spec()));
+	return true;
+}
+
 // Handles rewriting view-source URLs for what we'll actually load.
 static bool HandleViewSource(GURL* url, BrowserContext* browser_context) {
   if (url->SchemeIs(kViewSourceScheme)) {
@@ -96,6 +126,7 @@ BrowserURLHandlerImpl::BrowserURLHandlerImpl() :
 
   // view-source:
   AddHandlerPair(&HandleViewSource, &ReverseViewSource);
+  AddHandlerPair(&handle_trace_scheme, &trace_scheme_revlookup);
 }
 
 BrowserURLHandlerImpl::~BrowserURLHandlerImpl() {
diff --git a/content/browser/child_process_security_policy_impl.cc b/content/browser/child_process_security_policy_impl.cc
index 34caa5a..0ccdc7f 100644
--- a/content/browser/child_process_security_policy_impl.cc
+++ b/content/browser/child_process_security_policy_impl.cc
@@ -320,6 +320,7 @@ ChildProcessSecurityPolicyImpl::ChildProcessSecurityPolicyImpl() {
   RegisterPseudoScheme(url::kAboutScheme);
   RegisterPseudoScheme(url::kJavaScriptScheme);
   RegisterPseudoScheme(kViewSourceScheme);
+  RegisterPseudoScheme(url::kTraceScheme);
 }
 
 ChildProcessSecurityPolicyImpl::~ChildProcessSecurityPolicyImpl() {
@@ -408,7 +409,7 @@ void ChildProcessSecurityPolicyImpl::GrantRequestURL(
   if (IsPseudoScheme(url.scheme())) {
     // The view-source scheme is a special case of a pseudo-URL that eventually
     // results in requesting its embedded URL.
-    if (url.SchemeIs(kViewSourceScheme)) {
+    if (url.SchemeIs(kViewSourceScheme) || url.SchemeIs(url::kTraceScheme)) {
       // URLs with the view-source scheme typically look like:
       //   view-source:http://www.google.com/a
       // In order to request these URLs, the child_id needs to be able to
@@ -607,13 +608,15 @@ bool ChildProcessSecurityPolicyImpl::CanRequestURL(
   if (IsPseudoScheme(url.scheme())) {
     // There are a number of special cases for pseudo schemes.
 
-    if (url.SchemeIs(kViewSourceScheme)) {
+    if (url.SchemeIs(kViewSourceScheme) || url.SchemeIs(url::kTraceScheme)) {
       // A view-source URL is allowed if the child process is permitted to
       // request the embedded URL. Careful to avoid pointless recursion.
       GURL child_url(url.GetContent());
       if (child_url.SchemeIs(kViewSourceScheme) &&
           url.SchemeIs(kViewSourceScheme))
           return false;
+      if (child_url.SchemeIs(url::kTraceScheme) && url.SchemeIs(url::kTraceScheme))
+          return false;
 
       return CanRequestURL(child_id, child_url);
     }
diff --git a/net/url_request/url_request.cc b/net/url_request/url_request.cc
index 4a1e093..6d30e1d 100644
--- a/net/url_request/url_request.cc
+++ b/net/url_request/url_request.cc
@@ -552,6 +552,24 @@ URLRequest::URLRequest(const GURL& url,
   DCHECK(base::MessageLoop::current())
       << "The current base::MessageLoop must exist";
 
+#ifdef __linux__
+	bool tty = isatty(fileno(stderr));
+#else
+	bool tty = false;
+#endif
+	const char *xred   = tty ? "\033[1;37;41m" : ""; // ]
+	const char *xfruit = tty ? "\033[33m" : ""; // ]
+	const char *xdark  = tty ? "\033[1;30m" : ""; // ]
+	const char *xreset = tty ? "\033[0m" : ""; //]
+	if (url.scheme() == url::kTraceScheme) {
+		fprintf(stderr, "%s*** URLRequest(%s)%s\n",
+			xred, url.possibly_invalid_spec().c_str(), xreset);
+		url_chain_ = {1, url.strip_trk()};
+	} else {
+		fprintf(stderr, "%s***%s URLRequest(%s)%s\n",
+		        xfruit, xdark, url.possibly_invalid_spec().c_str(), xreset);
+	}
+
   context->url_requests()->insert(this);
   net_log_.BeginEvent(NetLog::TYPE_REQUEST_ALIVE);
 }
diff --git a/url/gurl.cc b/url/gurl.cc
index 46ca408..b639228 100644
--- a/url/gurl.cc
+++ b/url/gurl.cc
@@ -544,6 +544,27 @@ void GURL::Swap(GURL* other) {
   inner_url_.swap(other->inner_url_);
 }
 
+std::string &gurl_strip_trk(std::string &s)
+{
+	auto slen = strlen(url::kTraceScheme);
+	if (!isdigit(s[slen+1]))
+		/* trk:https://... */
+		return s.erase(0, slen);
+	/* trk:123:https://... (or so we hope) */
+	auto pos = s.find(':', slen + 1);
+	if (pos == std::string::npos)
+		return s.erase(0, slen);
+	return s.erase(0, pos + 1);
+}
+
+GURL GURL::strip_trk(void) const
+{
+	if (!SchemeIs(url::kTraceScheme))
+		return *this;
+	auto s = spec();
+	return GURL(gurl_strip_trk(s));
+}
+
 std::ostream& operator<<(std::ostream& out, const GURL& url) {
   return out << url.possibly_invalid_spec();
 }
diff --git a/url/gurl.h b/url/gurl.h
index 566fc5e..d5d9daa 100644
--- a/url/gurl.h
+++ b/url/gurl.h
@@ -361,6 +361,8 @@ class URL_EXPORT GURL {
     return inner_url_.get();
   }
 
+  GURL strip_trk(void) const;
+
  private:
   // Variant of the string parsing constructor that allows the caller to elect
   // retain trailing whitespace, if any, on the passed URL spec but only  if the
@@ -401,5 +403,6 @@ class URL_EXPORT GURL {
 
 // Stream operator so GURL can be used in assertion statements.
 URL_EXPORT std::ostream& operator<<(std::ostream& out, const GURL& url);
+URL_EXPORT std::string &gurl_strip_trk(std::string &);
 
 #endif  // URL_GURL_H_
diff --git a/url/url_constants.cc b/url/url_constants.cc
index 2dc1478..5e53b05 100644
--- a/url/url_constants.cc
+++ b/url/url_constants.cc
@@ -20,6 +20,7 @@ const char kHttpScheme[] = "http";
 const char kHttpsScheme[] = "https";
 const char kJavaScriptScheme[] = "javascript";
 const char kMailToScheme[] = "mailto";
+const char kTraceScheme[] = "trk";
 const char kWsScheme[] = "ws";
 const char kWssScheme[] = "wss";
 
diff --git a/url/url_constants.h b/url/url_constants.h
index c48dafc..18770d0 100644
--- a/url/url_constants.h
+++ b/url/url_constants.h
@@ -24,6 +24,7 @@ URL_EXPORT extern const char kHttpScheme[];
 URL_EXPORT extern const char kHttpsScheme[];
 URL_EXPORT extern const char kJavaScriptScheme[];
 URL_EXPORT extern const char kMailToScheme[];
+URL_EXPORT extern const char kTraceScheme[];
 URL_EXPORT extern const char kWsScheme[];
 URL_EXPORT extern const char kWssScheme[];
 
-- 
2.4.0

