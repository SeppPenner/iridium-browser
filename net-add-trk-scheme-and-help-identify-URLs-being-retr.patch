From f5e461cd4a783199c4cd6f0e2f38dcfd2da801c7 Mon Sep 17 00:00:00 2001
From: Jan Engelhardt <jengelh@inai.de>
Date: Wed, 20 May 2015 01:34:50 +0200
Subject: [PATCH 59/76] net: add "trk:" scheme and help identify URLs being
 retrieved

The Chromium codebase has left us with a number of suspect URLs, and
we want to know if the browser attempts to contact those sites.

This patch introduces a new scheme, "trk:", which, when attempted to
being processed, will dump a warning onto the screen as the resource
is loaded. All URLs we think are suspect are "blacklisted" by
prepending the new scheme to an existing URL:

	trk:1234:https://clients4.google.com/
	trk:https://clients4.google.com/ (unnumbered old variant)
	trk:0.1234:https://... (stderr only, no UI reporting)

Upon seeing a warning, we then know to investigate further, and either
(a) whitelist the URL, that is, remove the trk: prefix and not show
the warning, and/or (b) disable the particular feature which caused
the loading of the URL in the first place, by default.

Implementation:

We hack up the URLFetcher class which sits in the network stack, and
most of the URL that get loaded pass through here. The trk: prefix is
stripped and processing continues with the inner URL.
---
 chrome/BUILD.gn                               |  3 +
 chrome/app/chrome_main.cc                     | 21 +++++++
 .../chrome_autocomplete_scheme_classifier.cc  |  1 +
 chrome/browser/history/history_utils.cc       |  1 +
 chrome/browser/ui/browser_navigator.cc        |  7 ++-
 chrome/browser/ui/singleton_tabs.cc           |  3 +-
 components/infobars/core/infobar_delegate.h   |  1 +
 .../omnibox/browser/autocomplete_input.cc     |  6 +-
 content/browser/browser_url_handler_impl.cc   | 20 ++++++
 .../child_process_security_policy_impl.cc     |  1 +
 iridium/BUILD.gn                              |  9 +++
 iridium/trkbar.cpp                            | 45 ++++++++++++++
 iridium/trkbar.h                              | 33 ++++++++++
 iridium/trknotify.cpp                         | 62 +++++++++++++++++++
 iridium/trknotify.h                           | 20 ++++++
 net/url_request/url_request.cc                |  6 ++
 net/url_request/url_request.h                 |  2 +
 tools/metrics/histograms/enums.xml            |  1 +
 url/gurl.cc                                   | 35 +++++++++++
 url/gurl.h                                    |  5 ++
 url/url_constants.cc                          |  1 +
 url/url_constants.h                           |  1 +
 22 files changed, 280 insertions(+), 4 deletions(-)
 create mode 100644 iridium/BUILD.gn
 create mode 100644 iridium/trkbar.cpp
 create mode 100644 iridium/trkbar.h
 create mode 100644 iridium/trknotify.cpp
 create mode 100644 iridium/trknotify.h

diff --git chrome/BUILD.gn chrome/BUILD.gn
index f06eeeee05c8f..8da8b2417e3e8 100644
--- chrome/BUILD.gn
+++ chrome/BUILD.gn
@@ -211,6 +211,8 @@ if (!is_android && !is_mac) {
       sources += [ "app/chrome_exe_main_aura.cc" ]
     }
 
+    deps += ["//iridium:trknotify"]
+
     if (is_linux) {
       sources += [
         "app/chrome_dll_resource.h",
@@ -224,6 +226,7 @@ if (!is_android && !is_mac) {
         # Chromium functionality directly into the executable.
         ":browser_dependencies",
         ":child_dependencies",
+        "//iridium:trknotify",
 
         # For the sampling profiler.
         "//chrome/common/profiler",
diff --git chrome/app/chrome_main.cc chrome/app/chrome_main.cc
index 8e41e2f210993..14c493f087504 100644
--- chrome/app/chrome_main.cc
+++ chrome/app/chrome_main.cc
@@ -17,6 +17,10 @@
 #include "content/public/common/content_switches.h"
 #include "headless/public/headless_shell.h"
 #include "ui/gfx/switches.h"
+#if !defined(CHROME_MULTIPLE_DLL_CHILD)
+#	include "net/url_request/url_request.h"
+#	include "iridium/trknotify.h"
+#endif
 
 #if defined(OS_CHROMEOS)
 #include "chrome/browser/chromeos/tracing_allocation_failure_tracker.h"
@@ -49,6 +53,19 @@ int ChromeMain(int argc, const char** argv);
 }
 #endif
 
+#if !defined(CHROME_MULTIPLE_DLL_CHILD)
+static void trace_url_request(const std::string &caller, const GURL &url)
+{
+	iridium::log_url_request(caller, url);
+	if (url.scheme() != url::kTraceScheme)
+		/* Do not show infobar for non-trk URLs */
+		return;
+	if (url.is_trq())
+		return;
+	iridium::trace_url_request(caller, url);
+}
+#endif
+
 #if defined(OS_WIN)
 DLLEXPORT int __cdecl ChromeMain(HINSTANCE instance,
                                  sandbox::SandboxInterfaceInfo* sandbox_info,
@@ -115,6 +132,10 @@ int ChromeMain(int argc, const char** argv) {
   }
 #endif  // defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN)
 
+#if !defined(CHROME_MULTIPLE_DLL_CHILD)
+  net::trace_urlreq_cb = &trace_url_request;
+#endif
+
   int rv = content::ContentMain(params);
 
   return rv;
diff --git chrome/browser/autocomplete/chrome_autocomplete_scheme_classifier.cc chrome/browser/autocomplete/chrome_autocomplete_scheme_classifier.cc
index e90ea488b1c08..cadb447aed817 100644
--- chrome/browser/autocomplete/chrome_autocomplete_scheme_classifier.cc
+++ chrome/browser/autocomplete/chrome_autocomplete_scheme_classifier.cc
@@ -55,6 +55,7 @@ ChromeAutocompleteSchemeClassifier::GetInputTypeForScheme(
   if (base::IsStringASCII(scheme) &&
       (ProfileIOData::IsHandledProtocol(scheme) ||
        base::LowerCaseEqualsASCII(scheme, content::kViewSourceScheme) ||
+       base::LowerCaseEqualsASCII(scheme, url::kTraceScheme) ||
        base::LowerCaseEqualsASCII(scheme, url::kJavaScriptScheme) ||
        base::LowerCaseEqualsASCII(scheme, url::kDataScheme))) {
     return metrics::OmniboxInputType::URL;
diff --git chrome/browser/history/history_utils.cc chrome/browser/history/history_utils.cc
index 3f54bbb409fec..8971b7e96ad2f 100644
--- chrome/browser/history/history_utils.cc
+++ chrome/browser/history/history_utils.cc
@@ -21,6 +21,7 @@ bool CanAddURLToHistory(const GURL& url) {
       url.SchemeIs(content::kChromeDevToolsScheme) ||
       url.SchemeIs(content::kChromeUIScheme) ||
       url.SchemeIs(content::kViewSourceScheme) ||
+      url.SchemeIs(url::kTraceScheme) ||
       url.SchemeIs(chrome::kChromeNativeScheme) ||
       url.SchemeIs(chrome::kChromeSearchScheme) ||
       url.SchemeIs(dom_distiller::kDomDistillerScheme))
diff --git chrome/browser/ui/browser_navigator.cc chrome/browser/ui/browser_navigator.cc
index ecb449a9970b7..5d1d72a048df2 100644
--- chrome/browser/ui/browser_navigator.cc
+++ chrome/browser/ui/browser_navigator.cc
@@ -804,7 +804,12 @@ bool IsURLAllowedInIncognito(const GURL& url,
     return stripped_url.is_valid() &&
            IsURLAllowedInIncognito(stripped_url, browser_context);
   }
-
+	if (url.SchemeIs(url::kTraceScheme)) {
+		/* Same as view-source:, strip prefix and re-check. */
+		auto url2 = url.strip_trk();
+		return url2.is_valid() &&
+		       IsURLAllowedInIncognito(url2, browser_context);
+	}
   return IsHostAllowedInIncognito(url);
 }
 
diff --git chrome/browser/ui/singleton_tabs.cc chrome/browser/ui/singleton_tabs.cc
index 6d99c680556d8..3d4f0ccfae8e1 100644
--- chrome/browser/ui/singleton_tabs.cc
+++ chrome/browser/ui/singleton_tabs.cc
@@ -99,7 +99,8 @@ int GetIndexOfExistingTab(Browser* browser, const NavigateParams& params) {
 
     // Skip view-source tabs. This is needed because RewriteURLIfNecessary
     // removes the "view-source:" scheme which leads to incorrect matching.
-    if (tab_url.SchemeIs(content::kViewSourceScheme))
+    if (tab_url.SchemeIs(content::kViewSourceScheme) ||
+        tab_url.SchemeIs(url::kTraceScheme))
       continue;
 
     GURL rewritten_tab_url = tab_url;
diff --git components/infobars/core/infobar_delegate.h components/infobars/core/infobar_delegate.h
index b1933ea71e79e..56cd2fba2adce 100644
--- components/infobars/core/infobar_delegate.h
+++ components/infobars/core/infobar_delegate.h
@@ -168,6 +168,7 @@ class InfoBarDelegate {
     MIXED_CONTENT_DOWNLOAD_INFOBAR_DELEGATE_ANDROID = 98,
     CONDITIONAL_TAB_STRIP_INFOBAR_ANDROID = 99,
     LITE_MODE_HTTPS_IMAGE_COMPRESSION_INFOBAR_ANDROID = 100,
+    TRACKING_ALERT_INFOBAR_DELEGATE = 9001,
   };
 
   // Describes navigation events, used to decide whether infobars should be
diff --git components/omnibox/browser/autocomplete_input.cc components/omnibox/browser/autocomplete_input.cc
index 7511ab261a18e..0fe8c003e4021 100644
--- components/omnibox/browser/autocomplete_input.cc
+++ components/omnibox/browser/autocomplete_input.cc
@@ -488,6 +488,7 @@ void AutocompleteInput::ParseForEmphasizeComponents(
   // For the view-source and blob schemes, we should emphasize the host of the
   // URL qualified by the view-source or blob prefix.
   if ((base::LowerCaseEqualsASCII(scheme_str, kViewSourceScheme) ||
+       base::LowerCaseEqualsASCII(scheme_str, url::kTraceScheme) ||
        base::LowerCaseEqualsASCII(scheme_str, url::kBlobScheme)) &&
       (static_cast<int>(text.length()) > after_scheme_and_colon)) {
     // Obtain the URL prefixed by view-source or blob and parse it.
@@ -561,9 +562,10 @@ int AutocompleteInput::NumNonHostComponents(const url::Parsed& parts) {
 bool AutocompleteInput::HasHTTPScheme(const base::string16& input) {
   std::string utf8_input(base::UTF16ToUTF8(input));
   url::Component scheme;
-  if (url::FindAndCompareScheme(utf8_input, kViewSourceScheme, &scheme)) {
+  if (url::FindAndCompareScheme(utf8_input, url::kTraceScheme, &scheme))
+    gurl_strip_trk(utf8_input);
+  else if (url::FindAndCompareScheme(utf8_input, kViewSourceScheme, &scheme))
     utf8_input.erase(0, scheme.end() + 1);
-  }
   return url::FindAndCompareScheme(utf8_input, url::kHttpScheme, nullptr);
 }
 
diff --git content/browser/browser_url_handler_impl.cc content/browser/browser_url_handler_impl.cc
index 88bc53e9626eb..e98eccb313fc3 100644
--- content/browser/browser_url_handler_impl.cc
+++ content/browser/browser_url_handler_impl.cc
@@ -15,9 +15,28 @@
 #include "content/public/common/url_constants.h"
 #include "content/public/common/url_utils.h"
 #include "url/gurl.h"
+#include "net/url_request/url_request.h"
 
 namespace content {
 
+static bool handle_trace_scheme(GURL *url, BrowserContext *)
+{
+	if (!url->SchemeIs(url::kTraceScheme))
+		return false;
+	if (net::trace_urlreq_cb != NULL)
+		(*net::trace_urlreq_cb)("handle_trace_scheme", *url);
+	*url = url->strip_trk();
+	return false;
+}
+
+static bool trace_scheme_revlookup(GURL *url, BrowserContext *)
+{
+	if (url->SchemeIs(url::kTraceScheme))
+		return false;
+	*url = GURL(url::kTraceScheme + (":" + url->spec()));
+	return true;
+}
+
 // Handles rewriting view-source URLs for what we'll actually load.
 static bool HandleViewSource(GURL* url, BrowserContext* browser_context) {
   if (url->SchemeIs(kViewSourceScheme)) {
@@ -101,6 +120,7 @@ BrowserURLHandlerImpl::BrowserURLHandlerImpl() :
   AddHandlerPair(&HandleViewSource, &ReverseViewSource);
 
   GetContentClient()->browser()->BrowserURLHandlerCreated(this);
+  AddHandlerPair(&handle_trace_scheme, &trace_scheme_revlookup);
 }
 
 BrowserURLHandlerImpl::~BrowserURLHandlerImpl() {
diff --git content/browser/child_process_security_policy_impl.cc content/browser/child_process_security_policy_impl.cc
index ca111c5b80ee9..ed5c79f5bf6b7 100644
--- content/browser/child_process_security_policy_impl.cc
+++ content/browser/child_process_security_policy_impl.cc
@@ -647,6 +647,7 @@ ChildProcessSecurityPolicyImpl::ChildProcessSecurityPolicyImpl() {
   RegisterPseudoScheme(url::kJavaScriptScheme);
   RegisterPseudoScheme(kViewSourceScheme);
   RegisterPseudoScheme(kGoogleChromeScheme);
+  RegisterPseudoScheme(url::kTraceScheme);
 }
 
 ChildProcessSecurityPolicyImpl::~ChildProcessSecurityPolicyImpl() {
diff --git iridium/BUILD.gn iridium/BUILD.gn
new file mode 100644
index 0000000000000..913b266e04df6
--- /dev/null
+++ iridium/BUILD.gn
@@ -0,0 +1,9 @@
+config("trknotify_c") {
+        include_dirs = ["..", "../third_party/skia/include/config", "../third_party/skia/include/core"]
+}
+
+component("trknotify") {
+        sources = ["trkbar.cpp", "trkbar.h", "trknotify.cpp", "trknotify.h"]
+        public_configs = [":trknotify_c"]
+        deps = ["//chrome/browser/ui"]
+}
diff --git iridium/trkbar.cpp iridium/trkbar.cpp
new file mode 100644
index 0000000000000..16013abaf19b9
--- /dev/null
+++ iridium/trkbar.cpp
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2015 The Iridium Authors
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "base/strings/utf_string_conversions.h"
+#include "components/infobars/core/infobar.h"
+#include "iridium/trkbar.h"
+
+namespace content {
+
+void TrkBar::Create(InfoBarService *s, const GURL &url)
+{
+	s->AddInfoBar(s->CreateConfirmInfoBar(
+		std::unique_ptr<ConfirmInfoBarDelegate>(new TrkBar(url))
+	));
+}
+
+bool TrkBar::ShouldExpire(const NavigationDetails &) const
+{
+	return false;
+}
+
+TrkBar::TrkBar(const GURL &url) :
+	ConfirmInfoBarDelegate(), m_url(url)
+{
+}
+
+base::string16 TrkBar::GetMessageText(void) const
+{
+	return base::ASCIIToUTF16("Loading traced URL: " + m_url.spec());
+}
+
+int TrkBar::GetButtons(void) const
+{
+	return BUTTON_NONE;
+}
+
+infobars::InfoBarDelegate::InfoBarIdentifier TrkBar::GetIdentifier(void) const
+{
+	return TRACKING_ALERT_INFOBAR_DELEGATE;
+}
+
+}; /* namespace content */
diff --git iridium/trkbar.h iridium/trkbar.h
new file mode 100644
index 0000000000000..b251feca039b6
--- /dev/null
+++ iridium/trkbar.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2015 The Iridium Authors.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef IRIDIUM_TRKBAR_H
+#define IRIDIUM_TRKBAR_H 1
+
+#include "chrome/browser/infobars/infobar_service.h"
+#include "components/infobars/core/confirm_infobar_delegate.h"
+#include "url/gurl.h"
+
+namespace content {
+
+class TrkBar : public ConfirmInfoBarDelegate {
+	public:
+	static void Create(InfoBarService *, const GURL &);
+	bool ShouldExpire(const NavigationDetails &) const override;
+
+	private:
+	TrkBar(const GURL &);
+	base::string16 GetMessageText(void) const override;
+	int GetButtons(void) const override;
+	infobars::InfoBarDelegate::InfoBarIdentifier GetIdentifier(void) const override;
+
+	GURL m_url;
+	DISALLOW_COPY_AND_ASSIGN(TrkBar);
+};
+
+}; /* namespace content */
+
+#endif /* IRIDIUM_TRKBAR_H */
diff --git iridium/trknotify.cpp iridium/trknotify.cpp
new file mode 100644
index 0000000000000..7ed71676f92a9
--- /dev/null
+++ iridium/trknotify.cpp
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2015 The Iridium Authors.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include <cstdio>
+#ifdef __linux__
+#	include <unistd.h>
+#endif
+#include "base/task/post_task.h"
+#include "base/task/task_traits.h"
+#include "chrome/browser/infobars/infobar_service.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/browser_finder.h"
+#include "chrome/browser/ui/tabs/tab_strip_model.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "url/url_constants.h"
+#include "iridium/trkbar.h"
+#include "iridium/trknotify.h"
+
+namespace iridium {
+
+void log_url_request(const std::string &caller, const GURL &url)
+{
+#ifdef __linux__
+	bool tty = isatty(fileno(stderr));
+#else
+	bool tty = false;
+#endif
+	const char *xred   = tty ? "\033[1;37;41m" : ""; // ]
+	const char *xfruit = tty ? "\033[33m"      : ""; // ]
+	const char *xdark  = tty ? "\033[1;30m"    : ""; // ]
+	const char *xreset = tty ? "\033[0m"       : ""; // ]
+
+	if (url.scheme() == url::kTraceScheme)
+		fprintf(stderr, "%s*** %s(%s)%s\n", xred, caller.c_str(),
+		        url.possibly_invalid_spec().c_str(), xreset);
+	else
+		fprintf(stderr, "%s***%s %s(%s)%s\n", xfruit, xdark,
+		        caller.c_str(), url.possibly_invalid_spec().c_str(),
+		        xreset);
+}
+
+static void __trace_url_request(const std::string &caller, const GURL &url)
+{
+	auto browser = chrome::FindLastActive();
+	if (browser == NULL)
+		return;
+
+	auto service = InfoBarService::FromWebContents(browser->tab_strip_model()->GetActiveWebContents());
+	content::TrkBar::Create(service, url);
+}
+
+void trace_url_request(const std::string &caller, const GURL &url)
+{
+	base::PostTask(FROM_HERE, {content::BrowserThread::UI},
+		base::Bind(&__trace_url_request, caller, url));
+}
+
+}; /* namespace iridium */
diff --git iridium/trknotify.h iridium/trknotify.h
new file mode 100644
index 0000000000000..3c58d22a44265
--- /dev/null
+++ iridium/trknotify.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2015 The Iridium Authors.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef IRIDIUM_TRKNOTIFY_H
+#define IRIDIUM_TRKNOTIFY_H 1
+
+#include <string>
+#include "url/gurl.h"
+
+namespace iridium {
+
+extern void log_url_request(const std::string &, const GURL &);
+extern void trace_url_request(const std::string &, const GURL &);
+
+}; /* namespace iridium */
+
+#endif /* IRIDIUM_TRKNOTIFY_H */
diff --git net/url_request/url_request.cc net/url_request/url_request.cc
index cbed158f16b92..68801addc436c 100644
--- net/url_request/url_request.cc
+++ net/url_request/url_request.cc
@@ -46,6 +46,8 @@ using std::string;
 
 namespace net {
 
+void (*trace_urlreq_cb)(const std::string &, const GURL &);
+
 namespace {
 
 // True once the first URLRequest was started.
@@ -562,6 +564,10 @@ URLRequest::URLRequest(const GURL& url,
   // Sanity check out environment.
   DCHECK(base::ThreadTaskRunnerHandle::IsSet());
 
+	if (trace_urlreq_cb != NULL)
+		(*trace_urlreq_cb)("URLRequest", url);
+	if (url.scheme() == url::kTraceScheme)
+		url_chain_[0] = url.strip_trk();
   context->url_requests()->insert(this);
   net_log_.BeginEvent(NetLogEventType::REQUEST_ALIVE, [&] {
     return NetLogURLRequestConstructorParams(url, priority_,
diff --git net/url_request/url_request.h net/url_request/url_request.h
index 643ab4ae8f0e4..6400ff347cd56 100644
--- net/url_request/url_request.h
+++ net/url_request/url_request.h
@@ -978,6 +978,8 @@ class NET_EXPORT URLRequest : public base::SupportsUserData {
   DISALLOW_COPY_AND_ASSIGN(URLRequest);
 };
 
+extern void NET_EXPORT (*trace_urlreq_cb)(const std::string &, const GURL &);
+
 }  // namespace net
 
 #endif  // NET_URL_REQUEST_URL_REQUEST_H_
diff --git tools/metrics/histograms/enums.xml tools/metrics/histograms/enums.xml
index c394f02fb8d81..2b143cad1c460 100644
--- tools/metrics/histograms/enums.xml
+++ tools/metrics/histograms/enums.xml
@@ -35330,6 +35330,7 @@ Called by update_gpu_driver_bug_workaround_entries.py.-->
   <int value="98" label="MIXED_CONTENT_DOWNLOAD_INFOBAR_DELEGATE_ANDROID"/>
   <int value="99" label="CONDITIONAL_TAB_STRIP_INFOBAR_ANDROID"/>
   <int value="100" label="LITE_MODE_HTTPS_IMAGE_COMPRESSION_INFOBAR_ANDROID"/>
+  <int value="9001" label="TRACKING_ALERT_INFOBAR_DELEGATE"/>
 </enum>
 
 <enum name="InfoBarResponse">
diff --git url/gurl.cc url/gurl.cc
index 9f4698fb0e4e8..d0755c75c35b9 100644
--- url/gurl.cc
+++ url/gurl.cc
@@ -502,6 +502,41 @@ bool GURL::IsAboutUrl(base::StringPiece allowed_path) const {
   return false;
 }
 
+std::string &gurl_strip_trk(std::string &s)
+{
+	auto slen = strlen(url::kTraceScheme);
+	if (!isdigit(s[slen+1]))
+		/* trk:https://... */
+		return s.erase(0, slen);
+	/* trk:123:https://... (or so we hope) */
+	auto pos = s.find(':', slen + 1);
+	if (pos == std::string::npos)
+		return s.erase(0, slen);
+	return s.erase(0, pos + 1);
+}
+
+bool gurl_is_trq(const std::string &s)
+{
+	auto slen = strlen(url::kTraceScheme);
+	/* trk:0.nnn:http:// makes for a quiet one */
+	return s[slen+1] == '0' && s[slen+2] == '.';
+}
+
+GURL GURL::strip_trk(void) const
+{
+	if (!SchemeIs(url::kTraceScheme))
+		return *this;
+	auto s = spec();
+	return GURL(gurl_strip_trk(s));
+}
+
+bool GURL::is_trq(void) const
+{
+	if (!SchemeIs(url::kTraceScheme))
+		return false;
+	return gurl_is_trq(spec());
+}
+
 std::ostream& operator<<(std::ostream& out, const GURL& url) {
   return out << url.possibly_invalid_spec();
 }
diff --git url/gurl.h url/gurl.h
index 9b6449b7c0102..1f9ec68effa30 100644
--- url/gurl.h
+++ url/gurl.h
@@ -434,6 +434,9 @@ class COMPONENT_EXPORT(URL) GURL {
   // See base/trace_event/memory_usage_estimator.h for more info.
   size_t EstimateMemoryUsage() const;
 
+  GURL strip_trk(void) const;
+  bool is_trq(void) const;
+
  private:
   // Variant of the string parsing constructor that allows the caller to elect
   // retain trailing whitespace, if any, on the passed URL spec, but only if
@@ -482,6 +485,8 @@ class COMPONENT_EXPORT(URL) GURL {
 // Stream operator so GURL can be used in assertion statements.
 COMPONENT_EXPORT(URL)
 std::ostream& operator<<(std::ostream& out, const GURL& url);
+COMPONENT_EXPORT(URL) std::string &gurl_strip_trk(std::string &);
+COMPONENT_EXPORT(URL) bool gurl_is_trq(const std::string &);
 
 COMPONENT_EXPORT(URL) bool operator==(const GURL& x, const GURL& y);
 COMPONENT_EXPORT(URL) bool operator!=(const GURL& x, const GURL& y);
diff --git url/url_constants.cc url/url_constants.cc
index 69399e420045f..23b8312deb6af 100644
--- url/url_constants.cc
+++ url/url_constants.cc
@@ -28,6 +28,7 @@ const char kMailToScheme[] = "mailto";
 // See also: https://www.iana.org/assignments/uri-schemes/prov/quic-transport
 const char kQuicTransportScheme[] = "quic-transport";
 const char kTelScheme[] = "tel";
+const char kTraceScheme[] = "trk";
 const char kWsScheme[] = "ws";
 const char kWssScheme[] = "wss";
 
diff --git url/url_constants.h url/url_constants.h
index f5a33dd813571..202dd8d4e1a15 100644
--- url/url_constants.h
+++ url/url_constants.h
@@ -34,6 +34,7 @@ COMPONENT_EXPORT(URL) extern const char kQuicTransportScheme[];
 COMPONENT_EXPORT(URL) extern const char kTelScheme[];
 COMPONENT_EXPORT(URL) extern const char kWsScheme[];
 COMPONENT_EXPORT(URL) extern const char kWssScheme[];
+COMPONENT_EXPORT(URL) extern const char kTraceScheme[];
 
 // Used to separate a standard scheme and the hostname: "://".
 COMPONENT_EXPORT(URL) extern const char kStandardSchemeSeparator[];
-- 
2.29.1

